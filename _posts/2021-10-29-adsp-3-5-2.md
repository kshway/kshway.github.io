---
title:  "[ADSP] 3과목 5장 정형데이터 마이닝 -2"
excerpt: "ADSP 3과목 헷갈리거나, 모르는거 정리하기"

categories:
  - ADSP

tags:
  - license

toc: true
toc_sticky: true
use_math: true

date: 2021-10-31
last_modified_at: 2021-10-31
---
# 인공신경망 분석
## 인공신경망 분석(ANN)
### 인공신경망이란
- 인간 뇌를 기반으로 한 추론 모델
- 뉴런은 기본적인 정보처리 단위

### 인공신경망연구
- 1943년 매컬럭과 피츠: 인간의 뇌를 수많은 신경세포가 연결된 하나이 디지털 네트워크 모형으로 간주하고 신경세포의 긴호처리 과정을 모형화하여 단순 패턴분류 모형을 개발
- 헵: 신경세포 사이의 연결강도를 조정하여 학습규칙개발
- 로젠블럿: 퍼셉트론이라는 인공세포 개발
- 비선형성의 한계점 발생 -XOR(Exclusive OR) 문제를 풀지 못하는 한계
- 홉필드, 러멜하트, 맥클랜드: 역전파알고리즘을 활용하여 비선형성을 극복한 다계층 퍼셉트론으로 새로운 인공신경망 모형등장

### 인간의 뇌를 형상화한 인공신경망
1. 인간뇌의 특징
    - 100억개의 뉴런과 6조개의 시냅스의 결합체
    - 인간의 뇌는 현존하는 어떤 컴퓨터보다 빠르고 매우 복잡, 비선형적, 병렬적인 정보처리 시스템과 같음
    - 적응성에 따라 '잘못된 답'에 대한 뉴런들 사이의 연결 약화, '올바른 답'에 대한 연결 강화
2. 인간의 뇌 모델링
    - 뉴런은 가중치가 있는 링크들로 연결
    - 뉴런은 여러 입력 신호를 받지만 출력 신호는 오직 하나만 생성

### 인공 신경망의 학습
- 신경망은 가중치를 반복적으로 조정하며 학습
- 뉴런은 링크로 연결되어 있고, 각 링크에는 수치적인 가중치가 있음
- 인공 신경망은 신경망의 가중치를 초기화하고 훈련데이터를 통해 가중치를 갱신하여 신경망의 구조를 선택하고, 활용할 학습 알고리즘을 결정한 후 신경망 훈련

### 인공신경망의 특징
1. 구조
    - 입력 링크에서 여러 신호를 받아서 새로운 활성화 수준을 계산, 출력 링크로 출력 신호를 보냄
    - 입력신호는 미가공 데이터 또는 다른 뉴런의 출력이 될 수 있음
    - 출력신호는 문제의 최종적인 해가 되거나 다른 뉴런에 입력
2. 뉴런의 계산
    - 뉴런은 전이함수, 즉 활성화 함수를 사용
    - 활성화 함수를 이용해 출력을 결정, 입력신호의 가중치 합을 계산하여 임계값과 비교
    - 가중치 합이 임계값보다 작으면 뉴런의 출력은 -1, 크거나 같으면 +1
3. 뉴런의 활성화 함수
    - 시그모이드 함수
        - 로지스틱 회귀분석과 유사하며 0~1의 확률값 가짐
    - softmax함수
        - 표준화지수 함수로도 불림
        - 출력값이 여러개로 주어지고 목표치가 다범주인경우 각 범주에 속할 사후확률 제공
    - Relu함수
        - 입력값이 0이라는 0, 0이상은 x값을 가지는 함수
4. 단일 뉴런의 학습(단층 퍼셉트론)
    - 퍼셉트론은 선형 결합기와 하드 리미터로 구성
    - 초평면은 n차원 공간을 두개의 영역으로 나눔
    - 초평면을 선형 분리 함수로 정의

### 신경망 모형 구축시 고려사항
1. **입력 변수**
    - 신경망 모형은 그 복잡성으로 인하여 입력 자료의 선택에 매우 민감
    - 입력변수가 범주형 또는 연속형변수일때 아래의 조건이 신경망 모형에 적합
    ```
    범주형 변수: 모든 범주에서 일정 빈도 이상의 값을 갖고 각 범주의 빈도가 일정할 때
    연속형 변수: 입력변수 값들의 범위가 변수간의 큰 차이가 없을 떄
    ```
    - 연속형 변수의 경우 그 분포가 평균을 중심으로 대칭이 아니면 좋지 않은 결과를 도출하기 때문에 아래와 같은 방법을 활용
    ```
    변환: 고객의 소득(대부분 평균미만이고 특정 고객의 소득이 매우 큰): 로그변환
    범주화: 각 범주의 빈도가 비슷하게 되도록 설정
    ```
    - 범주형 변수의 경우 가변수화하여 적용하고 가능하면 모든 범주형 변수는 같은 범위를 갖도록 가변수화 하는 것이 좋음
2. **가중치의 초기값과 다중 최소값 문제**
    - 역전파 알고리즘은 초기값에 따라 결과가 많이 달라지므로 초기값의 선택은 매우 중요
    - 가중치가 0이면 시그모이드 함수는 선형이 되고 신경망 모형은 근사적으로 선형모형
    - 일반적으로 초기값은 0 근처로 랜덤하게 선택하므로 초기 모형은 선형모형에 가깝고, 가중치 값이 증가할수록 비선형모형이 됨(초기값이 0이면 반복하여도 값이 전혀 변하지 않고, 너무 크면 좋지 않은 해를 주는 문제점을 내포)
3. **학습모드**
    - 온라인 학습모드
        - 각 관측값을 순차적으로 하나씩 신경망에 투입하여 가중치 추정값이 매번 바뀜
        - 일반적으로 속도가 빠르며 훈련자료에 유사값이 많은 경우 그 차이가 더 두드러짐
        - 훈련자료가 비정상성과 같이 특이한 성질을 가진 경우가 좋음
        - 국소최솟값에서 벗어나기 쉬움
    - 확률적 학습 모드
        - 온라인 학습 모드와 같으나 신경망에 투입되는 관측값의 순서가 랜덤
    - 배치 학습 모드
        - 전체 훈련자료를 동시에 신경망에 투입
4. **은닉층과 은닉노드**
    - 신경망을 적용할 때 가장 중요한 부분이 모형의 선택(은닉층의 수와 은닉노드의 수 결정)
    - 은닉층과 은닉노드가 많으면 가중치가 많아져서 과대 적합 문제 발생
    - 은닉층과 은닉노드가 적으면 과소적합 문제 발생
    - 은닉층의 수가 하나인 신경망은 범용 근사자이므로 모든 매끄러운 함수를 근사적으로 표현할 수 있음. 그러므로 가능하면 은닉층은 하나로 선정
    - 은닉노드의 수는 적절히 큰 값으로 놓고 가중치를 감소시키며 적용하는 것이 좋음
5. **과대 적합 문제**
    - 신경망에서는 많은 가중치를 추정해야 하므로 과대적합문제 빈번
    - 알고리즘의 조기종료와 가중치 감소 기법으로 해결
    - 모형이 적합하는 과정에서 검증오차가 증가하기 시작하면 반복을 중지하는 조기종료 시행
    - 선형모형의 능형회귀와 유사한 가중치 감소라는 벌점화 기법 활용

# 군집분석
## 군집분석
### 개요
- 각 객체의 유사성을 측정하여 유사성이 높은 대상 집단을 분류, 군집에 속한 객체들의 유사성과 서로다른 군집에 속한 객체간의 상이성을 규명하는 분석 방법
- 특성에 따라 고객을 여러 개의 배타적인 집단으로 나누는 것
- 결과는 구체적인 군집분석 방법에 따라 차이
- 군집의 개수나 구조에 대한 가정 없이 데이터들 사이의 거리를 기준으로 군집화 유도
- 마케팅 조사에서 소비자들의 상품구매행동이나 life style에 따른 소비자군 분류하여 시장전략 수립 등에 활용

- 계층적 군집
    - 합병형
        - 단일(최단) 연결법
        - 평균 연결법
        - Ward 연결법
        - 완전(최장) 연결법
        - 중심연결법
    - 분리형
        - 다이아나 방법
- 분할적 군집
    - 프로토타입
        - K-중심 군집
        - 퍼지 군집
        - K-평균 군집
        - K-중앙값 군집
        - K-메도이드 군집
    - 분포기반
        - 혼합분포군집
    - 밀도기반
        - 중심밀도 군집
        - 밀도기반

### 특징
1. 요인분석과 차이점
    - 요인분석은 유사한 변수를 함께 묶어주는 것이 목적
2. 판변분석과의 차이점
    - 판별분석은 사전에 집단이 나누어져 있는 자료를 통해 새로운 데이터를 기존의 집단에 할당하는 것이 목적

## 거리
군집분석에서는 관측 데이터 간 유사성이나 근접성을 측정해 어느 군집으로 묶을 수 있는지 판단

### 연속형 변수의 경우
- **유클리디안 거리**
    - 데이터간의 유사성을 측정할 때 많이 사용하는 거리
    - 통계적 개념이 내포되어있지 않아 변수들의 산포 정도가 전혀 감안되어 있지 않음
- **표준화 거리**
    - 해당변수의 표준편차로 척도 변환한 후 유클리드안 거리를 계산하는 방법
    - 표준화하게 되면 척도의 차이, 분산의 차이로 인한 왜곡을 피할 수 있음
- **마할라노비스 거리**
    - 통계적 개념이 포함된 거리
    - 변수들의 산포를 고려하여 이를 표준화한 거리
    - 두 벡터 사이의 거리를 산포를 의미하는 표본공분산으로 나눠주어야 하며, 그룹에 대한 사전 지식 없이는 표본공분산 S를 계산할 수 없음
- **페비셰프 거리**
- **맨하탄 거리**
    - 유클리디안 거리와 함꼐 가장 많이 사용되는 거리
    - 맨하탄에서 건물에서 건물을 가기위한 최단 거리를 구하기 위해 고안된 거리
- **캔버라 거리**
- **민코우스키 거리**
    - 맨하탄 거리와 유클리디안 거리를 한번에 표현한 공식
    - L1 거리(맨하탄거리), L2 거리(유클리디안 거리)라 불리고 있음

### 범주형 변수의 경우
- **자카드 거리**
- **자카드 계수**
- **코사인 거리**
    - 문서를 유사도를 기준으로 분류 혹은 그루핑 할 떄 유용하게 사용
- **코사인 유사도**
    - 두 개체의 백터 내적의 코사인 값을 이용하여 측정된 벡터간의 유사한 정도

## 계층적 군집분석
- 계층적 군집방법은 n개의 군집으로 시작해 점차 군집의 개수를 줄여 나가는 방법
- 계층적 군집을 형성하는 방법에는 합병형 방법, 분리형 방법이 있음

### 최단연결법(single linkage, nearest neighbor)
- n*n 거리행렬에서 거리가 가장 가까운 데이터를 묶어서 군집 형성
- 군집과 군집 또는 데이터와의 거리를 계산 시 최단거리(min)를 거리로 계산하여 거리행렬 수정을 진행
- 수정된 거리행렬에서 거리가 가까운 데이터 또는 군집을 새로운 군집으로 형성

### 최장연결법(complete linkage, farthest neighbor)
- 군집과 군집 또는 데이터와의 거리를 계산할 때 최장거리를 거리로 계산하여 거리 행렬을 수정

### 평균연결법(average linkage)
- 군집과 군집 또는 데이터와의 거리를 계산할 때 평균을 거리로 계산하여 거리행렬 수정

### 와드연결법(ward linkage)
- 군집내 편차들의 제곱합을 고려한 방법
- 군집 간 정보의 손실을 최소화하기 위해 군집화를 진행

### 군집화
- 거리행렬을 통해 가장 가까운 거리의 객체들간의 관계를 규명하고 덴드로그램을 그림
- 덴드로그램을 보고 군집의 개수를 변화해 가면서 적절한 군집 수 선정
- 군집의 수는 분석 목적에 따라 선정할 수 있지만 대부분 5개 이상의 군집은 잘 활용하지 않음
- 군집화 단계
    1. 거리행렬을 기준으로 덴드로그램을 그림
    2. 덴드로그램의 최상단부터 세로축의 개수에 따라 가로선을 그어 군집의 개수 선택
    3. 각 객체들의 구성을 고려해서 적절한 군집수 선정

## 비계층적 군집분석
n개의 개체를 g개의 군집으로 나눌 수 있는 모든 가능한 방법을 점검해 최적화한 군집 형성

### K-평균 군집분석
- 주어진 데이터를 k개의 클러스터로 묶는 알고리즘, 각 클러스터와 거리 차이의 분산을 최소화하는 방식으로 동작

### K-평균 군집분석과정
- 원하는 군집의 개수와 초기값들을 정해 seed중심으로 군집형성
- 각 데이터를 거리가 가장 가까운 seed가 있는 군집으로 분류
- 각 군집의 seed 값을 다시 계산
- 모든 개체가 군집으로 할당될 때까지 위 과정 반복

### K-평균 군집분석의 특징
- 거리계산을 통해 군집화가 이루어지므로 연속형 변수에 활용 가능
- K개의 초기 중심값은 임의로 선택 가능(가급적 멀리 떨어지는 것이 바람직)
- 초기 중심값을 임의로 선택할 때 일렬로 선택하면 군집혼합되지 않고 층으로 나누어질 수 있어 주의(초기 중심값의 선정에 따라 결과 달라질 수 있음)
- 초기 중심으로 부터 오차 제곱합을 최소화하는 방향으로 군집이 형성되는 탐욕적알고리즘이므로 안정된 군집은 보장하나 최적이라는 보장없음

|장점|단점|
|:---:|:---:|
|알고리즘이 단순하며, 빠르게 수행되어 분석 방법 적용이 용이|군집의 수, 가중치와 거리 정의 어려움|
|계층적 군집분석에 비해 많은 양의 데이터를 다룰 수 있음|사전에 주어진 목적이 없으므로 결과해석 어려움|
|내부 구조에 대한 사전정보가 없어도 의미있는 자료구조를 찾을 수 있음|잡음이나 이상값의 영향을 많이 받음|
|다양한 형태의 데이터에 적용이 가능|볼록한 형태가 아닌 군집이 존재할 경우 성능이 떨어짐|
||초기 군집수 결정에 어려움이 있음|

## 혼합 분포 군집(mixture distrivution clustering)
### 개요
- 모형 기반의 군집 방법, 데이터가 k개의 모수적 모형의 가중합으로 표현되는 모집단 모형으로부터 나왔다는 가정하에서 모수와 함께 가중치를 자료로부터 추정하는 방법 사용
- K개의 각 모형은 군집을 의미, 각 데이터는 추정된 k개의 모형 중 어느 모형으로부터 나왔을 확률이 높은지에 따라 군집의 분류가 이루어짐
- 흔히 혼합모형에서의 모수와 가중치의 추정에는 EM 알고리즘 사용

### EM 알고리즘의 진행과정
- 각 자료에 대해 Z의 조건부분포로부터 조건부 기댓값을 구할 수 있음
- 관측변수 X와 잠재변수 Z를 포함하는 (X,Z)에 대한 로그-가능도함수에 Z 대신 상수값인 Z의 조건부 기댓값을 대입하면, 로그-가능도함수를 최대로 하는 모수를 쉽게 찾을수 있음(M-단계)
- 갱신된 모수 추정치에 대해 위 과정을 반복한다면 수렴하는 값을 얻게 되고, 이는 최대 가능도 추정치로 사용될 수 있음
- E-단계: 잠재변수 Z의 기대치 계산
- M-단계: 잠재변수 Z의 기대치를 이용하여 파라미터를 추정

### 혼합 분포 군집모형의 특징
- K-평균군집의 절차와 유사하지만 확률분포를 도입하여 군집을 수행
- 군집을 몇 개의 모수로 표현할 수 있으며, 서로 다른 크기나 모양의 군집을 찾을 수 있음
- EM 알고리즘을 이용한 모수 추정에서 데이터가 커지면 수렴에 시간이 걸릴 수 있음
- 군집의 크기가 너무 작으면 추정의 정도가 떨어지거나 어려울 수 있음
- K-평균군집과 같이 이상치 자료에 민감하므로 사전에 조치 필요

## SOM(Self Organizing Map)
### 개요
- 자기조직화지도 알고리즘은 코호넨에 의해 제시, 개발되었으며 코호넨 맵이라고도 알려져있음
- SOM은 비지도 신경망으로 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬하여 지도의 형태로 형상화
- 이러한 형상화는 입력 변수의 위치 관계를 그대로 보존한다는 특징있음
- 실제 공간의 입력 변수가 가까이 있으면, 지도상에도 가까운 위치

### 구성
SOM 모델은 두개의 인공신경망층으로 구성
1. 입력층(Input Layer)
    - 입력변수의 개수와 동일하게 뉴런 수 존재
    - 입력층의 자료는 학습을 통하여 경쟁층에 정렬, 이를 지도라 부름
    - 입력층에 있는 각각의 뉴런은 경쟁층에 있는 각각의 뉴런들과 연결(완전 연결)
2. 경쟁층(Competitive layer: 2차원 격차로 구성된 층)
    - 입력벡터의 특성에 따라 벡터가 한 점으로 클러스터링 되는 층
    - SOM은 경쟁 학습으로 각각의 뉴런이 입력 벡터와 얼마나 가까운가를 계산하여 연결 강도를 반복적으로 재조정하여 학습
    - 이 과정을 거치면서 연결강도는 입력 패턴과 가장 유사한 경쟁층 뉴런이 승자
    - 입력 층의 표본 벡터에 가장 가까운 프로토타입 벡터를 선택해 BMU라고하며, 코호넨의 승자 독점의 학습 규칙에 따라 위상학적 이웃에 대한 연결 강도를 조정
    - 승자 독식 구조로 인해 경쟁층에는 승자 뉴런만이 나타나며, 승자와 유사한 연결 강도를 갖는 입력 패턴이 동일한 경쟁 뉴런으로 배열

### 특징
- 고차원의 데이터를 저차원의 지도 형태로 형상화하기 떄문에 시각적으로 이해가 쉬움
- 입력 변수의 위치 관계를 그대로 보존하기 때문에 실제 데이터가 유사하면 지도상에서 가깝게 표현
- 패턴 발견, 이미지 분석 등에서 뛰어난 성능을 보임
- 역전파 알고리즘 등을 이용하는 인공신경망과 달리 단 하나의 전방 패스를 사용함으로써 속도가 매우 빠름
- 실시간 학습처리 가능

### SOM과 신경망 모형 차이

|구분|신경망 모형|SOM|
|:---:|:---:|:---:|
|학습 방법|오차역전파법|경쟁학습방법|
|구성|입력층, 은닉층, 출력층|입력층, 2차원 격자 형태의 경쟁층|
|기계 학습 방법의 분류|지도학습|비지도학습|

### 최신 군집분석 기법

#### Hierarchical Clustering

```r
idx <- sample(1:dim(iris)[1],40)
iris.s <- iris[idx,]
iris.s$Species <- NULL
hc <- hclust(dist(iris.s),method="ave")
plot(hc, hang=-1, labels = iris$Species[idx])
```

![Rplot](https://user-images.githubusercontent.com/91586956/139584541-3225de4e-a7e4-4e72-9011-53ab5a2668dd.png)


#### K-means Clustering

```r
data(iris)
newiris <- iris
newiris$Species <- NULL
kc <- kmeans(newiris,3)

table(iris$Species, kc$cluster)

plot(newiris[c("Sepal.Length","Sepal.Width")], col = kc$cluster)
```

![Rplot01](https://user-images.githubusercontent.com/91586956/139584555-a90573ec-e2a4-4681-abc6-ceb303074bdc.png)

# 연관분석
## 연관규칙
### 연관규칙분석의 개념
- 연관성 분석은 흔히 장바구니분석 또는 서열분석이라고 불림
- 기업의 데이터베이스에서 상품의 구매, 서비스 등 일련의 거래 또는 사건들 간의 규칙을 발견하기 위해 적용
- 장바구니 분석: '장바구니에 무엇이 같이 들어 있는지에 대한 분석'
- 서열분석: 'A를 산 다음에 B를 산다'

### 연관규칙의 형태
조건과 반응의 형태(if- then)로 이루어져 있음  
만일 A가 일어나면 B가 일어난다

### 연관규칙의 측도
산업의 특성에 따라 지지도, 신뢰도, 향상도 값을 잘 보고 규칙을 선택해야 함

1. 지지도(support)
    - 전체 거래 항목 중 항목 A와 항목 B를 동시에 포함하는 거래의 비율로 정의
2. 신뢰도(confidence)
    - 항목 A를 포함한 거래 중에서 항목 A와 항목 B가 같이 포함될 확률
    - 연관성의 정도를 파악할 수 있음
3. 향상도(Lift)
    - A가 구매되지 않았을 때 품목 B의 구매확률에 비해 A가 구매됐을 때 품목 B의 구매확률의 증가 비
    - 연관규칙 A-> B는 품목 A와 품목 B의 구매가 서로 관련이 없는 경우에 향상도가 1이됨

### 연관규칙의 절차
- 최소 지지도보다 큰 집합만을 대상으로 높은 지지도를 갖는 품목 집합을 찾는 것
- 처음에는 5%로 잡고 규칙이 충분히 도출되는지를 보고 다양하게 조절하여 시도
- 처음부터 너무 낮은 최소 지지도를 선정하는 것은 많은 리소스가 소모되므로 적절하지 않음
- 절차
    1. 최소 지지도 결정
    2. 품목 중 최소 지지도를 넘는 품목 분류
    3. 2가지 품목 집합 생성
    4. 반복적으로 수행해 빈발품목 집합을 찾음

### 연관규칙의 장점과 단점
- 장점
    - 탐색적인 기법으로 조건 반응으로 표현되는 연관성분석과 결과를 쉽게 이해할 수 있음
    - 강력한 비목적성 분석기법으로 분석 방향이나 목적이 특별히 없는 경우 목적변수가 없으므로 유용하게 활용
    - 사용이 편리한 분석 데이터의 형태로 거래 내용에 대한 데이터를 변환 없이 그 자체로 이용할 수 있는 간단한 자요 구조
    - 분석을 위한 계산 간단

- 단점
    - 품목수가 증가하면 분석에 필요한 계산은 기하급수적으로 증가
        - 이를 개선하기 위해 유사한 품목을 한 범주로 일반화
        - 연관 규칙의 신뢰도 하한을 새롭게 정의해 실제 드물게 관찰되는 의미가 적은 연관규칙은 제외
    - 너무 세분화한 품목을 갖고 연관성 규칙을 찾으면 의미없는 분석이 될 수도 있음
        - 적절히 구분되는 큰 범주로 구분해 전체 분석에 포함시킨 후 그 결과 중에서 세부적으로 연관규칙을 찾는 작업 수행
    - 거래량이 적은 품목은 당연히 포함된 거래수가 적을 것이고, 규칙발견시 제외하기 쉬움
        - 그 품목이 관련성을 살펴보고자 하는 중요한 품목이라면 유사한 품목들과 함께 범주로 구성하는 방법을 통해 연관성 규칙의 과정에 포함

### 순차패턴
- 동시에 구매될 가능성이 큰 상품군을 찾아내는 연관성분석에 시간이라는 개념을 포함시켜 순차적으로 구매 가능성이 큰 상품군을 찾아내는 것
- 연관성분석에서의 데이터 형태에서 각각의 고객으로부터 발생한 구매시점에 대한 정보가 포함

## 기존 연관성분석의 이슈
- 대용량 데이터에 대한 연관성분석이 불가능
- 시간이 많이 걸리거나 기존 시스템에서 실행시 시스템 다운되는 현상 발생

## 최근 연관성분석 동향
- 거래내역에 포함되어 있는 모든 품목의 개수가 n개 일 때, 품목들의 전체집합에서 추출할 수 있는 품목 부분집합의 개수는 $2^n - 1$(공집합 제외)개다. 그리고 가능한 모든 연관 규칙의 개수는 $3^n - 2^{n+1} + 1$개이다.
- 이때 모든 가능한 품목 부분집합의 개수를 줄이는 방식으로 작동하는 것이 Apriori 알고리즘
- 거래내역 안에 포함된 품목의 개수를 줄여 비교하는 횟수를 줄이는 방식으로 작동하는 것이 FP-Growth 알고리즘

### Apriori 알고리즘
- 최소 지지도보다 큰 지지도 값을 갖는 품목의 집합을 빈발항목집합이라고 함
- 모든 품목집합에 대한 지지도를 전부 계산하는 것이 아니라, 최소 지지도 이상의 빈발항목집합을 찾은 후 그것들에 대해서만 연관규칙을 계산하는 것
- 1994년에 발표된 1세대 알고리즘으로 구현과 이해하기가 쉽다는 장점이 있으나, 지지도가 낮은 후보 생성 시 아이템의 개수가 많아지면 계산 복잡도가 증가한다는 문제점을 가지고 있음

### FP-Growth 알고리즘
- FP-Growth 알고리즘은 후보 빈발항목집합을 생성하지 않고, FP-Tree를 만든 후 분할정복 방식을 통해 APriori 알고리즘 보다 더 빠르게 빈발항목집합을 추출할 수 있는 방법
- Aprirori 알고리즘의 약점을 보완하기 위해 고안, 데이터베이스를 스캔하는 횟수가 작고, 빠른 속도로 분석가능

## 연관성분석 활용방안
- 장바구니 분석의 경우 실시간 상품추천을 통한 교차 판매에 응용
- 순차 패턴 분석은 A를 구매한 사람인데 B를 구매하지 않은 경우, B를 추천하는 교차판매 캠페인에 사용

## 연관성분석 예제

```r
> data(Groceries)
> inspect(Groceries[1:3])
    items                                                   
[1] {citrus fruit,semi-finished bread,margarine,ready soups}
[2] {tropical fruit,yogurt,coffee}                          
[3] {whole milk}                                            
> rules <- apriori(Groceries, parameter = list(support=0.01, confidence = 0.3))
Apriori

Parameter specification:
 confidence minval smax arem  aval originalSupport maxtime support minlen maxlen target  ext
        0.3    0.1    1 none FALSE            TRUE       5    0.01      1     10  rules TRUE

Algorithmic control:
 filter tree heap memopt load sort verbose
    0.1 TRUE TRUE  FALSE TRUE    2    TRUE

Absolute minimum support count: 98 

set item appearances ...[0 item(s)] done [0.00s].
set transactions ...[169 item(s), 9835 transaction(s)] done [0.00s].
sorting and recoding items ... [88 item(s)] done [0.00s].
creating transaction tree ... done [0.00s].
checking subsets of size 1 2 3 4 done [0.00s].
writing ... [125 rule(s)] done [0.00s].
creating S4 object  ... done [0.00s].
```
- apriori 알고리즘으로 연관규칙분석을 실행한 결과 총 88개의 아이템으로 연관규칙을 만들어냈으며 125개의 Rule이 발견되었음
- 규칙의 수가 너무 적으면 지지도와 신뢰도를 낮추고, 너무 많으면 지지도와 신뢰도를 높여야함

```r
> inspect(sort(rules,by=c("lift"), decreasing = TRUE)[1:20])
     lhs                                      rhs                support    confidence coverage   lift     count
[1]  {citrus fruit,other vegetables}       => {root vegetables}  0.01037112 0.3591549  0.02887646 3.295045 102  
[2]  {tropical fruit,other vegetables}     => {root vegetables}  0.01230300 0.3427762  0.03589222 3.144780 121  
[3]  {beef}                                => {root vegetables}  0.01738688 0.3313953  0.05246568 3.040367 171  
[4]  {citrus fruit,root vegetables}        => {other vegetables} 0.01037112 0.5862069  0.01769192 3.029608 102  
[5]  {tropical fruit,root vegetables}      => {other vegetables} 0.01230300 0.5845411  0.02104728 3.020999 121  
[6]  {other vegetables,whole milk}         => {root vegetables}  0.02318251 0.3097826  0.07483477 2.842082 228  
[7]  {whole milk,curd}                     => {yogurt}           0.01006609 0.3852140  0.02613116 2.761356  99  
[8]  {root vegetables,rolls/buns}          => {other vegetables} 0.01220132 0.5020921  0.02430097 2.594890 120  
[9]  {root vegetables,yogurt}              => {other vegetables} 0.01291307 0.5000000  0.02582613 2.584078 127  
[10] {tropical fruit,whole milk}           => {yogurt}           0.01514997 0.3581731  0.04229792 2.567516 149  
[11] {yogurt,whipped/sour cream}           => {other vegetables} 0.01016777 0.4901961  0.02074225 2.533410 100  
[12] {other vegetables,whipped/sour cream} => {yogurt}           0.01016777 0.3521127  0.02887646 2.524073 100  
[13] {tropical fruit,other vegetables}     => {yogurt}           0.01230300 0.3427762  0.03589222 2.457146 121  
[14] {root vegetables,whole milk}          => {other vegetables} 0.02318251 0.4740125  0.04890696 2.449770 228  
[15] {whole milk,whipped/sour cream}       => {yogurt}           0.01087951 0.3375394  0.03223183 2.419607 107  
[16] {citrus fruit,whole milk}             => {yogurt}           0.01026945 0.3366667  0.03050330 2.413350 101  
[17] {onions}                              => {other vegetables} 0.01423488 0.4590164  0.03101169 2.372268 140  
[18] {pork,whole milk}                     => {other vegetables} 0.01016777 0.4587156  0.02216573 2.370714 100  
[19] {whole milk,whipped/sour cream}       => {other vegetables} 0.01464159 0.4542587  0.03223183 2.347679 144  
[20] {curd}                                => {yogurt}           0.01728521 0.3244275  0.05327911 2.325615 170  
```

- 향상도를 기준으로 내림차순 정렬한 후 상위 5개의 규칙을 확인해 보았을 때, rhs의 제품만 구매할 확률에 비해 lhs의 제품을 샀을때 rhs제품을 구매할 확률이 약 3배가량 높음(Lift > 3 이기 때문)
- rhs와 lhs 제품간 결합상품 할인쿠폰 혹은 품목배치변경을 제안 할 수 있음